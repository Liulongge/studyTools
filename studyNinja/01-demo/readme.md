# make与ninja对比

## 背景对比
| 特性             | make                                  | ninja                                            |
|------------------|---------------------------------------|--------------------------------------------------|
| **设计目标**     | 通用构建工具, 强调灵活性和可扩展性           | 专为速度优化, 适合大型项目和高频增量编译               |
| **诞生背景**     | 1977年由Stuart Feldman开发, UNIX传统工具  | 2011年由Google开发, 用于解决Chrome项目的构建性能问题   |
| **复杂度**       | 高(支持 Shell 脚本、条件逻辑、函数等)      | 极低(仅核心构建功能, 无复杂逻辑)                       |
| **典型文件**     | Makefile(手动编写)                      | build.ninja(通常由CMake/GN生成)                     |

## make与ninja 性能对比

| 场景             | make                  | ninja                            |
|-----------------|-----------------------|----------------------------------|
| **全量构建**     | 较慢(需解析递归Makefile) | 快10%-30%(静态依赖图, 零解析开销)    |
| **增量构建**     | 慢(依赖全局重新分析)     | 极快(哈希比对文件变更, 毫秒级响)       |
| **启动开销**     | 高(需解析Makefile规则)  | 近乎为零(构建文件为预编译的二进制格)    |
| **内存占用**     | 较高(维护复杂规则)       | 极低(仅存储必要依赖关系)              |

## make与ninja生态系统对比

| 方面           | make                     | ninja                                  |
|---------------|--------------------------|----------------------------------------|
| **跨平台支持** | 主流平台支持(需适配)         | 跨平台(Windows/macOS/Linux)             |
| **IDE 集成**  | 广泛支持(但性能差)          | 逐渐普及(CLion/VSCode 已支持)             |
| **生成工具**   | 手动编写或Autotools生成     | 依赖CMake(90%)、GN(Chromium)、Meson等    |
| **典型用户**   | Linux内核、传统C/C++项目    | Chrome/Android/LLVM/Fuchsia等超大型项目  |

## 如何选择构建工具？

| 场景                    | 推荐工具  | 理由                                 |
|------------------------|----------|-------------------------------------|
| 小型/传统项目            | make     | 学习成本低, 手动控制灵活                |
| 大型现代项目(>10万行代码) | ninja    | 显著提升开发效率(尤其适合高频增量编译)     |
| 需要复杂构建逻辑         | make     | 支持Shell脚本、条件判断和高级控制结构      |
| 嵌入式/资源受限环境      | ninja    | 低内存占用, 快速启动和执行                |
| 作为其他工具的生成目标    | ninja    | CMake的默认推荐后端, 支持自动化构建流程    |

## LLVM 项目性能实测对比(并行度"-j8")

| 指标              | make -j8   | ninja -j8  | 差异幅度     |
|------------------|------------|-------------|--------------|
| 全量构建时间       | 12m34s     | 9m47s       | **-22%**     |
| 增量构建(改1文件)  | 8.2s       | 0.9s        | **-89%**     |
| 内存占用峰值       | 1.2GB      | 380MB       | **-68%**     |

## 总结来说
| 推荐工具 | 使用场景                         |
|----------|----------------------------------|
| ninja    | 极致速度、大型项目、频繁构建     |
| make     | 灵活定制、维护旧系统、小型项目   |

# Ninja介绍
Ninja 是一个专注于速度的构建系统，其设计目标是尽可能快地执行构建任务。以下是 Ninja 的底层原理详解：
1. 静态依赖图

    1.1. 预先计算的依赖关系：与 make 不同，Ninja 使用的是在构建之前就已经确定好的静态依赖图。这意味着它不需要在每次构建时重新解析和分析依赖关系，从而大大减少了启动时间。
    
    1.2. 扁平化结构：Ninja 的构建文件（通常是 build.ninja）是基于规则定义的扁平化结构，这使得它能够快速解析和处理。
2. 高效的文件监控和增量构建
    
    2.1. 哈希校验：为了支持快速的增量构建，Ninja 通过比较文件内容的哈希值来检测文件是否发生了变化，而不是简单地检查文件修改时间。这种方式提高了增量构建的准确性。
    
    2.2. 毫秒级响应：由于采用了上述策略，即使在大型项目中，Ninja 也能实现毫秒级别的增量构建响应时间。
3. 低内存占用
    
    3.1. 精简的数据模型：Ninja 只存储必要的依赖信息，避免了不必要的数据开销。这种做法不仅降低了内存使用量，也加快了构建过程中的数据访问速度。
    
    3.2. 优化后的数据结构：内部使用高效的数据结构和算法来管理和查找依赖关系，进一步提升了性能表现。
4. 作为生成目标的后端
    
    与其他工具集成：虽然直接手写 .ninja 文件并不常见，但许多高级构建系统如 CMake、GN 和 Meson 都能输出 Ninja 格式的构建文件。这让开发者可以享受到 Ninja 带来的高性能优势，同时利用这些高级工具提供的丰富功能。
5. 二进制格式
    
    预编译的构建文件：Ninja 构建文件通常以一种接近于二进制的紧凑格式存在，这样可以在读取时减少解析时间，加快构建进程的启动速度。

总结
    
Ninja的设计理念围绕着“速度”展开，通过采用静态依赖图、高效文件监控机制、低内存占用以及与其他构建系统的良好集成，为用户提供了一个快速可靠的构建解决方案。特别是在处理大规模代码库或需要频繁进行增量构建的情况下，Ninja 显示出了明显的优势。